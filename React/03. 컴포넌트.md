# 컴포넌트

## 함수형 컴포넌트 & 클래스형 컴포넌트

둘 다 props 라는 인자를 받아 React element를 만든다.  
차이가 있다면 클래스형 컴포넌트에만 state 및 라이프사이클 API가 존재하고, 함수형 컴포넌트가 더 선언이 편하고 메모리 및 파일 크기가 적다는 것이다. 현재 state 및 라이프사이클 API는 리액트 Hooks를 통해 다른 방식으로 사용할 수 있게 되었기에, 공식 문서에서는 함수형 컴포넌트를 권장하고 있다.  
함수형에서 클래스형으로 전환해야 할 때는 render 안에 모든 내용을 담고 모든 props를 this.props로 대체하면 된다.

### 함수형 컴포넌트

```js
import React from "react";

function App(props) {
  return <div>app {props.name}</div>;
}
```

### 클래스형 컴포넌트

```js
import React, { Component } from "react";

class App extends Component {
  render() {
    return <div>app {this.props.name}</div>;
  }
}
```

## props

위에서 소개한 props는 읽기 전용의 속성으로, 사용자 정의 컴포넌트를 불러올 때 부모 컴포넌트에서 설정할 수 있다.

```js
const element = <App name="my-first-app" />;
```

- 위와 같이 사용자 정의 컴포넌트를 부르면, JSX attribute 및 자식들을 props 라는 단일 개체로 합쳐 컴포넌트에 보내는 것이다.

- 자식의 경우 특별히 attribute로 전달하지 않아도 `props.children`을 통해 접근 가능한데, 컴포넌트 태그 내부의 내용을 보여준다.

- `Default value`를 결정하고 싶을 경우 `App.defaultProps = {name:'이름'};`과 같이 설정해줄 수 있다.

- Props를 사용할 때 추천하는 것은 `Destructuring assignment`이다. 하나하나 props.name, props.date를 적는 것은 비효율적이기 때문에 함수의 인자를 props가 아닌 `function ({name, date})`처럼 받아서 name, date로 적을 수 있다.

- `import PropTypes from prop-types`로 import하여 타입 설정이 가능한데, `App.propTypes = {name: PropTypes.String.isRequired};`과 같이 설정할 수 있다. `isRequired`는 꼭 필요한 경우 붙여 필수 요소로 만들 수 있다.

## state

부모에서 설정하는 읽기 전용인 props와 다르게 state는 컴포넌트 내부에서 설정하고 바뀔 수 있는 값이다. 클래스형 컴포넌트는 자체적으로 가지고 있으며, 함수형 컴포넌트는 hooks를 사용해야 한다.  
후자의 경우에는 차후 hooks를 설명할 때 배울 것이고, 지금은 클래스형 컴포넌트에 대해서만 이야기하겠다.

state의 설정은 다음과 같이 constructor에서 가능하다.

```js
import React, { Component } from "react";
class App extends Component {
  constructor(props) {
    super(props);
    this.state = { date: new Date() };
  }
}
```

이때 부모의 생성자인 `super(props)`가 필요한 이유는 [super(props) 를 써야하는 이유](https://min9nim.github.io/2018/12/super-props/)를 참고하자. 간략하게 요약하자면, 다음과 같다.

1. **자바스크립트에서 super 선언 전에는 this를 사용할 수 없다**. 그 이유는 class에서 `this.<부모 프로퍼티>`를 통해 부모에게서 상속받은 프로퍼티를 접근할 때, super를 통해 부모 프로퍼티를 정의하지 않았다면 문제가 발생할 수 있기 때문이다.
2. 1번에서 설명한 것을 이 경우로 한정하면 `React.Component` 객체 생성 시 props 속성의 초기화를 위해 부모에게 props를 전달하는 것이다.
3. (번외로) `super(props)` 대신 `super()`만 호출해도 생성자 호출 후에는 props에 접근이 가능한데, 이는 리액트가 생성자 호출 후 자동으로 객체에 props를 설정해주기 때문이다. 그러나 `생성자 내부`에서는 설정하지 않기 때문에, 엄밀하게 말하자면 `super(prop)`을 쓰는 이유는 생성자 내부에서 props에 접근하기 위함이다.

## Reference

1. 김민준, 『리액트를 다루는 기술』, 길벗 (2019)
2. https://ko.reactjs.org/docs/components-and-props.html
3. https://ko.reactjs.org/docs/state-and-lifecycle.html
4. https://min9nim.github.io/2018/12/super-props/ - [React] super(props) 를 써야하는 이유
